--- a/agent/core.py
+++ b/agent/core.py
@@ -225,91 +225,6 @@
     return out
 
 
-def _auto_alias(normalized: str) -> str:
-    """
-    Convert common natural phrasings into the canonical commands your handlers expect.
-    This is where "aliases for everything" actually happens.
-    """
-    s = _apply_global_replacements(normalized)
-
-    # ---- status/state normalization ----
-    # Most of your handlers use "<thing> status" or "<thing> state".
-    # We unify a bunch of common variants.
-    status_map = {
-        "system status": "system info",
-        "system info status": "system info",
-        "storage status": "storage",
-        "disk status": "storage",
-        "drive status": "storage",
-
-        "display status": "display status",
-        "screen status": "display status",
-
-        "audio status": "audio status",
-        "sound status": "audio status",
-        "volume status": "audio status",
-
-        "bluetooth status": "bluetooth status",
-        "wifi status": "network status",
-        "network status": "network status",
-
-        "power status": "power status",
-        "battery status": "power status",
-
-        "runner status": "runner is elevated",
-        "runner elevated status": "runner is elevated",
-    }
-
-    if s in status_map:
-        return status_map[s]
-
-    # ---- common turns on/off forms ----
-    # wifi
-    s = s.replace("enable wifi", "wifi on")
-    s = s.replace("turn on wifi", "wifi on")
-    s = s.replace("disable wifi", "wifi off")
-    s = s.replace("turn off wifi", "wifi off")
-
-    # bluetooth
-    s = s.replace("enable bluetooth", "bluetooth on")
-    s = s.replace("turn on bluetooth", "bluetooth on")
-    s = s.replace("disable bluetooth", "bluetooth off")
-    s = s.replace("turn off bluetooth", "bluetooth off")
-
-    # night light
-    s = s.replace("enable night light", "night light on")
-    s = s.replace("turn on night light", "night light on")
-    s = s.replace("disable night light", "night light off")
-    s = s.replace("turn off night light", "night light off")
-
-    # brightness
-    s = s.replace("increase brightness", "brightness up")
-    s = s.replace("decrease brightness", "brightness down")
-
-    # volume
-    s = s.replace("increase volume", "volume up")
-    s = s.replace("decrease volume", "volume down")
-
-    return s
-
-
 def _did_you_mean(normalized: str) -> Optional[str]:
     if not normalized or normalized in KNOWN_COMMANDS:
         return None
@@ -300,16 +215,6 @@
     # Default: return cleaned phrase
     return s
 
 
-def _resolve_command(raw: str) -> str:
-    """
-    One place to normalize -> auto-alias -> manual ALIASES override.
-    Manual ALIASES wins at the end so you can force anything.
-    """
-    n = _normalize(raw)
-    n = _auto_alias(n)
-    return ALIASES.get(n, n)
-
-
 ALIASES = {
     # runner
     "runner elevated": "runner is elevated",
@@ -777,6 +682,211 @@
     except Exception:
         return {}
 
 
+# -------------------------
+# MK3.3 Dev task router
+# -------------------------
+
+_DEV_TRIGGER_RE = re.compile(
+    r"""\b(
+        fix|debug|refactor|implement|add\s+(a\s+)?feature|add\s+support|make\s+it\s+work|
+        code\s+review|cleanup|document|lint|format|optimi[sz]e|performance\s+issue|
+        stack\s*trace|traceback|exception|error\s+code|build\s+failed|test\s+failed
+    )\b""",
+    re.IGNORECASE | re.VERBOSE,
+)
+
+_DEV_SHORTCUTS = {
+    "dev status", "devmode status", "dev",
+    "sandbox reset", "dev sandbox reset", "reset sandbox",
+    "discard patch", "dev discard patch", "cancel patch",
+    "apply patch", "dev apply patch",
+    "propose patch",
+}
+
+def _is_dev_request(text_lower: str, normalized: str) -> bool:
+    # Don't intercept explicit dev shortcuts (those are handled later)
+    if normalized in _DEV_SHORTCUTS:
+        return False
+
+    # Strong signals that we're talking about code
+    if "traceback" in text_lower:
+        return True
+    if "syntaxerror" in text_lower or "importerror" in text_lower or "typeerror" in text_lower:
+        return True
+    if "exception" in text_lower or "stack trace" in text_lower:
+        return True
+    if "error" in text_lower and ("line " in text_lower or "file " in text_lower):
+        return True
+
+    return bool(_DEV_TRIGGER_RE.search(text_lower))
+
+
+def _extract_repo_paths(text_in: str):
+    # Accept both forward/back slashes, only inside repo-ish folders
+    candidates = re.findall(r"\b(?:agent|runner|config|workspace)\\[\w\-./\\]+\b", text_in)
+    candidates += re.findall(r"\b(?:agent|runner|config|workspace)/[\w\-./]+\b", text_in)
+
+    cleaned = []
+    for p in candidates:
+        p = p.replace("\\", "/")
+        if p.startswith("workspace/"):
+            # code.read_file is repo-bounded; don't read workspace
+            continue
+        if p not in cleaned:
+            cleaned.append(p)
+    return cleaned[:6]
+
+
+def _extract_query_tokens(user_text: str):
+    raw = user_text or ""
+    tokens = set()
+
+    for t in re.findall(r"[A-Za-z_][A-Za-z0-9_\.]{2,}", raw):
+        tl = t.lower()
+        if tl in ("jarvis", "python", "windows", "please"):
+            continue
+        if len(t) >= 4:
+            tokens.add(t)
+
+    for t in list(tokens):
+        if t.lower().endswith(("error", "exception")):
+            tokens.add(t)
+
+    return list(tokens)[:8]
+
+
+def _summarize_matches(matches, limit=25) -> str:
+    out = []
+    for m in matches[:limit]:
+        f = m.get("file", "")
+        ln = m.get("line_no", "")
+        line = m.get("line", "")
+        out.append(f"{f}:{ln}: {line}")
+    return "\n".join(out)
+
+
+def _dev_collect_context(user_text: str) -> str:
+    paths = _extract_repo_paths(user_text)
+    tokens = _extract_query_tokens(user_text)
+
+    search_blobs = []
+    read_blobs = []
+
+    for p in paths:
+        out = _run_tool("code.read_file", {"path": p, "max_lines": 160, "start_line": 1})
+        if out and isinstance(out, dict) and out.get("result"):
+            lines = out["result"].get("lines", [])
+            read_blobs.append(f"--- FILE: {p} ---\n" + "\n".join(lines))
+
+    base_path = "agent"
+    if "runner" in (user_text or "").lower():
+        base_path = "runner"
+
+    for tok in tokens[:3]:
+        out = _run_tool("code.search", {"query": tok, "path": base_path, "max_files": 50, "max_matches": 30})
+        if out and isinstance(out, dict) and out.get("result"):
+            res = out["result"]
+            matches = res.get("matches", [])
+            if matches:
+                search_blobs.append(f"--- SEARCH: {tok} (in {res.get('path')}) ---\n" + _summarize_matches(matches))
+
+    context = []
+    if search_blobs:
+        context.append("\n\n".join(search_blobs))
+    if read_blobs:
+        context.append("\n\n".join(read_blobs))
+
+    return "\n\n".join(context).strip()
+
+
+def _dev_generate_patch(user_request: str, context_blob: str, compile_feedback: str = "") -> Dict[str, Any]:
+    tool_catalog = "\n".join([
+        "You can reference these tools but DO NOT call them directly:",
+        "- code.search(query, path)  # already executed; see context",
+        "- code.read_file(path)      # already executed; see context",
+        "- dev.propose_patch(diff, description)  # Jarvis will call it",
+    ])
+
+    prompt = [
+        "You are the CODER model for the Jarvis repo.",
+        "Goal: generate a SMALL, correct unified diff (git apply compatible) to implement the requested change.",
+        "Rules:",
+        "- Output JSON ONLY.",
+        "- Schema: {\"description\": string, \"diff\": string}.",
+        "- diff MUST be a unified diff with file paths relative to repo root, like 'agent/core.py'.",
+        "- Do NOT include backticks. Do NOT include explanations outside JSON.",
+        "- Prefer minimal edits. Keep formatting consistent.",
+        "",
+        tool_catalog,
+        "",
+        f"User request: {user_request}",
+    ]
+
+    if compile_feedback.strip():
+        prompt.append("")
+        prompt.append("Sandbox compile feedback (from previous attempt):")
+        prompt.append(compile_feedback)
+
+    if context_blob.strip():
+        prompt.append("")
+        prompt.append("Repo context:")
+        prompt.append(context_blob)
+
+    prompt.append("")
+    prompt.append("JSON:")
+
+    raw = _coder_model.chat(prompt).strip()
+    obj = _extract_first_json_object(raw) or {}
+    desc = obj.get("description", "").strip()
+    diff_text = obj.get("diff", "").rstrip() + "\n" if obj.get("diff") else ""
+
+    return {"description": desc, "diff": diff_text, "raw": raw}
+
+
+def _handle_dev_request(user_text: str) -> None:
+    print("Jarvis: Entering Dev Mode (sandbox-first).")
+
+    context_blob = _dev_collect_context(user_text)
+
+    last_feedback = ""
+    for attempt in range(1, 4):
+        patch = _dev_generate_patch(user_text, context_blob, compile_feedback=last_feedback)
+        diff_text = patch.get("diff", "")
+
+        if not diff_text.strip():
+            print("Jarvis: I couldn't produce a valid diff yet. Try including the error text or file path.")
+            return
+
+        desc = patch.get("description") or f"Dev Mode patch attempt {attempt}"
+        result = _run_tool("dev.propose_patch", {"diff": diff_text, "description": desc})
+
+        ok = False
+        feedback = ""
+        if isinstance(result, dict):
+            res = result.get("result") or {}
+            ok = bool(res.get("compileall_ok"))
+            feedback = (res.get("compileall_output_tail") or "").strip()
+
+        if ok:
+            print("Jarvis: âœ… Sandbox checks passed. If you want to apply this patch to the real repo, type: apply patch")
+            return
+
+        if not feedback:
+            print("Jarvis: Sandbox checks failed, but I couldn't retrieve compile output. Use `dev status` to inspect.")
+            return
+
+        print("Jarvis: Sandbox checks failed. I will attempt a fix based on the compile output.")
+        last_feedback = feedback
+
+    print("Jarvis: I tried a few times but couldn't get a clean sandbox pass. Use `dev status` to review the latest output.")
+    return
+
+
 def handle_user_message(user_message: str) -> None:
     global _PENDING_SUGGESTION
 
     raw = user_message or ""
@@ -789,6 +899,13 @@
     normalized = _normalize(raw)
     norm = _apply_global_replacements(normalized)
 
+    # -------------------------
+    # MK3.3 Dev Mode router (auto)
+    # -------------------------
+    if _is_dev_request(text_lower, normalized):
+        _handle_dev_request(raw)
+        return
+
 
     # -------------------------
     # HELP
     # -------------------------
--- a/agent/devtools.py
+++ b/agent/devtools.py
@@ -320,6 +320,7 @@
         "result": {
             "pending_patch": state["pending_patch"],
             "compileall_ok": ok,
+            "compileall_output_tail": compile_out[-4000:] if isinstance(compile_out, str) else "",
             "run_log": run_log,
         }
     }
